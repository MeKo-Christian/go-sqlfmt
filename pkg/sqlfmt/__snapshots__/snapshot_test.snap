
[TestSnapshotFormatting_StandardSQL/basic_SELECT - 1]
SELECT
  id,
  name
FROM
  users
WHERE
  active = true;
---

[TestSnapshotFormatting_StandardSQL/INSERT_statement - 1]
INSERT INTO
  users (name, email)
VALUES
  ('John', 'john@test.com');
---

[TestSnapshotFormatting_PostgreSQL/basic_SELECT - 1]
SELECT
  id,
  name
FROM
  users
WHERE
  active = true;
---

[TestSnapshotFormatting_N1QL/basic_N1QL_SELECT - 1]
SELECT
  name
FROM
  `travel-sample`
WHERE
  type = 'airline';
---

[TestSnapshotFormatting_DB2/DB2_basic_query - 1]
SELECT
  empno,
  lastname
FROM
  employee
WHERE
  workdept = 'A00';
---

[TestSnapshotFormatting_PLSQL/PL/SQL_basic_query - 1]
SELECT
  employee_id,
  last_name
FROM
  employees
WHERE
  department_id = 10;
---

[TestSnapshotFormatting_WithCustomConfig/uppercase_keywords - 1]
SELECT
  id,
  name
FROM
  users;
---

[TestSnapshotFormatting_PostgreSQL/JSON_operations - 1]
SELECT
  data ->> 'name' as name
FROM
  users
WHERE
  data ? 'active';
---

[TestSnapshotFormatting_MySQL/basic_SELECT - 1]
SELECT
  id,
  name
FROM
  users
WHERE
  active = true;
---

[TestSnapshotFormatting_MySQL/JSON_operations - 1]
SELECT
  profile->'$.name',
  settings->>'$.theme'
FROM
  users
WHERE
  data->'$.active' = 'true';
---

[TestSnapshotFormatting_MySQL/NULL-safe_equality - 1]
SELECT
  *
FROM
  users u
  LEFT JOIN profiles p ON u.id <=> p.user_id;
---

[TestSnapshotFormatting_MySQL/REGEXP_operations - 1]
SELECT
  name
FROM
  users
WHERE
  email REGEXP '^[a-z]+@'
  AND status NOT REGEXP '^(banned|suspended)$';
---

[TestSnapshotFormatting_MySQL/LIMIT_variations - 1]
SELECT
  *
FROM
  products
ORDER BY
  price
LIMIT
  20, 10;
---

[TestSnapshotFormatting_MySQL/ON_DUPLICATE_KEY_UPDATE - 1]
INSERT INTO
  products (id, name, price)
VALUES
  (1, 'Product A', 19.99)
ON DUPLICATE KEY UPDATE
  name = VALUES(name),
  price = VALUES(price),
  updated_at = NOW();
---

[TestSnapshotFormatting_MySQL/CTE_with_window_function - 1]
WITH
  sales_data AS (
    SELECT
      product_id,
      amount,
      ROW_NUMBER() OVER (
        PARTITION BY product_id
        ORDER BY
          amount DESC
      ) as rank
    FROM
      sales
  )
SELECT
  *
FROM
  sales_data
WHERE
  rank <= 3;
---

[TestSnapshotFormatting_MySQL/DDL_with_generated_columns - 1]
CREATE TABLE orders (
  id INT PRIMARY KEY,
  subtotal DECIMAL(10, 2),
  tax_rate DECIMAL(3, 4),
  total DECIMAL(10, 2) GENERATED ALWAYS AS (subtotal + (subtotal * tax_rate)) STORED
);
---

[TestSnapshotFormatting_MySQL/stored_procedure - 1]
CREATE PROCEDURE
  GetUserStats(IN user_id INT) BEGIN
    SELECT
      COUNT(*) as orders,
      SUM(total) as revenue
    FROM
      orders
    WHERE
      customer_id = user_id;
END;
---

[TestSnapshotFormatting_MySQL/MySQL_comments_and_backticks - 1]
SELECT
  /*! SQL_CALC_FOUND_ROWS */
  `user_id`, # hash comment
  "full_name"
FROM
  `user_table` -- standard comment
WHERE
  `active` = TRUE;
---

[TestSnapshotFormatting_SQLite/basic_SELECT - 1]
SELECT
  id,
  name
FROM
  users
WHERE
  active = true;
---

[TestSnapshotFormatting_SQLite/JSON_operations - 1]
SELECT
  data ->> 'name' as name,
  profile -> 'settings'
FROM
  users
WHERE
  data -> 'active' = 'true';
---

[TestSnapshotFormatting_SQLite/all_placeholder_styles - 1]
SELECT
  *
FROM
  users
WHERE
  id = ?
  AND name = :name
  AND email = @email
  AND status = $status
  AND created_at > ?2;
---

[TestSnapshotFormatting_SQLite/LIMIT_variations - 1]
SELECT
  *
FROM
  products
ORDER BY
  price
LIMIT
  10 OFFSET 20;
---

[TestSnapshotFormatting_SQLite/LIMIT_variations - 2]
SELECT
  *
FROM
  products
ORDER BY
  price
LIMIT
  20, 10;
---

[TestSnapshotFormatting_SQLite/UPSERT_with_ON_CONFLICT - 1]
INSERT INTO
  products (id, name, price)
VALUES
  (1, 'Product A', 19.99)
ON CONFLICT
(id)
DO UPDATE
SET
  name = excluded.name,
  price = excluded.price;
---

[TestSnapshotFormatting_SQLite/INSERT_OR_REPLACE - 1]
INSERT OR REPLACE
  INTO cache (key, value, expires_at)
VALUES
  (
    'user:123',
    '{"name":"John"}',
    datetime('now', '+1 day')
  );
---

[TestSnapshotFormatting_SQLite/CTE_with_RECURSIVE - 1]
WITH
  RECURSIVE factorial(n, fact) AS (
    SELECT
      1,
      1
    UNION ALL
    SELECT
      n + 1,
      (n + 1) * fact
    FROM
      factorial
    WHERE
      n < 10
  )
SELECT
  *
FROM
  factorial;
---

[TestSnapshotFormatting_SQLite/window_functions - 1]
SELECT
  employee_id,
  department,
  salary,
  ROW_NUMBER() OVER (
    PARTITION BY department
    ORDER BY
      salary DESC
  ) as rank
FROM
  employees;
---

[TestSnapshotFormatting_SQLite/CTE_with_window_functions - 1]
WITH
  sales_data AS (
    SELECT
      product_id,
      amount,
      ROW_NUMBER() OVER (
        PARTITION BY product_id
        ORDER BY
          amount DESC ROWS BETWEEN UNBOUNDED PRECEDING
          AND CURRENT ROW
      ) as rank
    FROM
      sales
  )
SELECT
  *
FROM
  sales_data
WHERE
  rank <= 3;
---

[TestSnapshotFormatting_SQLite/DDL_with_generated_columns - 1]
CREATE TABLE
  orders (
    id INTEGER PRIMARY KEY,
    subtotal REAL,
    tax_rate REAL DEFAULT 0.08,
    total REAL GENERATED ALWAYS AS (subtotal + (subtotal * tax_rate)) STORED
  ) STRICT;
---

[TestSnapshotFormatting_SQLite/CREATE_INDEX_IF_NOT_EXISTS - 1]
CREATE UNIQUE INDEX
  IF NOT EXISTS idx_users_email ON users(email)
WHERE
  active = 1;
---

[TestSnapshotFormatting_SQLite/PRAGMA_statements - 1]
PRAGMA
  foreign_keys = ON;

PRAGMA
  journal_mode = WAL;

PRAGMA
  synchronous = NORMAL;
---

[TestSnapshotFormatting_SQLite/CREATE_TRIGGER - 1]
CREATE TRIGGER
  update_modified_time
AFTER
UPDATE
  ON users
  FOR EACH ROW BEGIN
    UPDATE
      users
    SET
      modified_at = datetime('now')
    WHERE
      id = NEW.id;
END;
---

[TestSnapshotFormatting_SQLite/CREATE_VIEW_with_CTE - 1]
CREATE VIEW
  active_users_summary AS
WITH
  user_stats AS (
    SELECT
      user_id,
      COUNT(*) as order_count
    FROM
      orders
    GROUP BY
      user_id
  )
SELECT
  u.name,
  us.order_count
FROM
  users u
  JOIN user_stats us ON u.id = us.user_id
WHERE
  u.active = 1;
---

[TestSnapshotFormatting_SQLite/identifier_quoting_styles - 1]
SELECT
  "double_quoted",
  `backtick_quoted`,
  [bracket_quoted]
FROM
  "table name"
WHERE
  `field name` = 'value';
---

[TestSnapshotFormatting_SQLite/blob_literals_and_concatenation - 1]
SELECT
  name || ' - ' || description as full_name,
  X'DEADBEEF' as binary_data
FROM
  products
WHERE
  data = X'48656C6C6F';
---

[TestSnapshotFormatting_SQLite/NULL_handling - 1]
SELECT
  *
FROM
  users
WHERE
  email IS NOT NULL
  AND status IS DISTINCT FROM 'deleted'
  AND name IS NOT DISTINCT FROM 'admin';
---

[TestSnapshotFormatting_SQLite/GLOB_and_LIKE_patterns - 1]
SELECT
  *
FROM
  files
WHERE
  name GLOB '*.txt'
  OR path LIKE '%/temp/%'
  AND name NOT GLOB 'temp*';
---

[TestSnapshotFormatting_SQLite/WITHOUT_ROWID_table - 1]
CREATE TABLE
  lookup (key TEXT PRIMARY KEY, value TEXT) WITHOUT ROWID;
---

[TestSnapshotFormatting_SQLite/complex_integrated_example - 1]
WITH
  RECURSIVE category_tree AS (
    SELECT
      id,
      name,
      parent_id,
      0 as level
    FROM
      categories
    WHERE
      parent_id IS NULL
    UNION ALL
    SELECT
      c.id,
      c.name,
      c.parent_id,
      ct.level + 1
    FROM
      categories c
      JOIN category_tree ct ON c.parent_id = ct.id
  ),
  sales_summary AS (
    SELECT
      p.category_id,
      COUNT(*) as order_count,
      SUM(oi.quantity * oi.price) as total_revenue,
      ROW_NUMBER() OVER (
        ORDER BY
          SUM(oi.quantity * oi.price) DESC
      ) as revenue_rank
    FROM
      order_items oi
      JOIN products p ON oi.product_id = p.id
    WHERE
      oi.created_at >= date('now', '-1 month')
    GROUP BY
      p.category_id
  )
SELECT
  ct.name || ' (Level ' || ct.level || ')' as category_name,
  ss.order_count,
  ss.total_revenue,
  ss.revenue_rank
FROM
  category_tree ct
  JOIN sales_summary ss ON ct.id = ss.category_id
WHERE
  ss.revenue_rank <= 10
ORDER BY
  ss.revenue_rank;
---
